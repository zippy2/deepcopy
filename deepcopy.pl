#!/usr/bin/perl
#
# Copyright (C) 2016 Red Hat, Inc.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library.  If not, see
# <http://www.gnu.org/licenses/>.
#
# Authors:
#       Michal Privoznik <mprivozn@redhat.com>
#

use strict;
use warnings;
use Data::Dumper;
use Getopt::Long;

my $mode = "debug";
my $res = GetOptions("mode=s" => \$mode);

die "cannot parse command line options" unless $res;

die "unknown mode '$mode', expecting 'header', 'source' or 'debug'"
    unless $mode =~ /^(header|source|debug)$/;

my @includes = ("stdlib.h", "string.h", "structs.h", "structs_gen.h");
my %structs;

# check whether struct in %structs is defined and if so whether it already
# contains a member
# $1 -> struct name
# $2 -> member name
sub check_duplicates {
    my $structName = shift;
    my $member = shift;
    if (not defined $structs{$structName}) {
        return 0;
    }
    for my $m (@{$structs{$structName}}) {
        if ($m->{member} eq $member) {
            return 1;
        }
    }
    return 0;
}

sub print_banner {
    print <<__EOF__;
/* Automatically generated by deepcopy.pl.
 * Do not edit this file. Any changes you make will be lost.
 */
__EOF__
}

sub generate_header {
    foreach my $structName (sort { $a cmp $b } keys %structs) {
        my $struct = $structs{$structName};
        print "\ntypedef struct _$structName $structName;\n";
        print "typedef $structName *${structName}Ptr;\n";
        print "struct _$structName {\n";
        for my $m (@{$struct}) {
            print "    $m->{type} $m->{member};\n";
        }
        print "};\n\n";
        print "${structName}Ptr ${structName}Copy(const ${structName} *src);\n";
        print "void ${structName}Free(${structName}Ptr s);\n";
    }
}

sub generate_includes {
    foreach my $incl (@includes) {
        print "#include \"$incl\"\n";
    }
}

sub generate_copy {
    foreach my $structName (sort { $a cmp $b } keys %structs) {
        my $struct = $structs{$structName};
        print "\n${structName}Ptr\n";
        print "${structName}Copy(const ${structName} *src)\n";
        print "{\n";
        print "    ${structName}Ptr ret = NULL;\n";
        print "\n";
        print "    if (VIR_ALLOC(ret) < 0)\n";
        print "        goto error;\n";
        print "\n";
        print "    memcpy(ret, src, sizeof(*ret));\n";
        for my $m (@{$struct}) {
            if ($m->{member} =~ m/^\*\w+/) {
                my $member = substr $m->{member}, 1;
                if ($m->{type} =~ m/char/) {
                    print "    if (VIR_STRDUP(ret->${member}, src->${member}) < 0)\n";
                    print "        goto error;\n";
                } elsif (defined $structs{$m->{type}}) {
                    print "    if (src->${member} &&\n";
                    print "        !(ret->${member} = $m->{type}Copy(src->${member})))\n";
                    print "        goto error;\n";
                } else {
                    die("Unhandled type $m->{type}");
                }
            }
        }
        print "    return ret;\n";
        print " error:\n";
        print "    ${structName}Free(ret);\n";
        print "    return NULL;\n";
        print "}\n";
    }
}

sub generate_free {
    foreach my $structName (sort { $a cmp $b } keys %structs) {
        my $struct = $structs{$structName};
        print "\nvoid\n";
        print "${structName}Free(${structName}Ptr s)\n";
        print "{\n";
        print "    if (!s)\n";
        print "        return;\n";
        print "\n";
        for my $m (@{$struct}) {
            if ($m->{member} =~ m/^\*\w+/) {
                my $member = substr $m->{member}, 1;
                if ($m->{type} =~ m/char/) {
                    print "    VIR_FREE(s->${member});\n";
                } elsif (defined $structs{$m->{type}}) {
                    print "    $m->{type}Free(s->${member});\n";
                } else {
                    die("Unhandled type $m->{type}");
                }
            }
        }
        print "    VIR_FREE(s);\n";
        print "}\n";
    }
}

my $in_struct = 0;
my $structName;

while (<>) {
    if (m/^struct (\S*)$/) {
        $in_struct = 1;
        $structName = $1;
        next;
    } elsif (m/^\s+(\S+)\s+(\S+);$/) {
        die ("Syntax error on line $.") unless $in_struct;
        my $type = $1;
        my $member = $2;
        my %rec;
        ${rec}{type} = $1;
        ${rec}{member} = $2;
        if (check_duplicates($structName, $member)) {
            die("Duplicate member $member in struct $structName at line $.");
        }
        push (@{${structs}{$structName}}, \%rec);
    } elsif (m/^\n$/) {
        $in_struct = 0;
        next;
    } else {
        die ("Syntax error on line $.");
    }
}

#print Dumper(\%structs);

if ($mode eq "debug") {
    generate_header();
    generate_copy();
    generate_free();
} elsif ($mode eq "header") {
    print_banner();
    generate_header();
} elsif ($mode eq "source") {
    print_banner();
    generate_includes();
    generate_copy();
    generate_free();
}
